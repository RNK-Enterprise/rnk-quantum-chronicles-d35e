// @ts-nocheck
export class ModernRollDialog{constructor(l,t="generic",e={}){this.actor=l,this.rollType=t,this.options=e,this.rollConfig={advantage:!1,disadvantage:!1,bonus:0,penalty:0,criticalConfirm:!1,rollType:t}}async show(){return new Promise(l=>{new Dialog({title:`${this.options.title||"Roll"} Configuration`,content:this.getHTML(),buttons:{roll:{icon:'<i class="fas fa-dice-d20"></i>',label:"Roll",callback:t=>{this.readFromHTML(t),l(this.rollConfig)}},cancel:{icon:'<i class="fas fa-times"></i>',label:"Cancel",callback:()=>l(null)}},default:"roll",close:()=>l(null)}).render(!0)})}getHTML(){this.rollType.includes("attack")||this.rollType.includes("save")||this.rollType.includes("skill");let l='\n      <form class="modern-roll-dialog">\n        <div class="form-group">\n          <label for="roll-advantage">\n            <input type="checkbox" id="roll-advantage" name="advantage" />\n            Advantage (Roll twice, use higher)\n          </label>\n        </div>\n\n        <div class="form-group">\n          <label for="roll-disadvantage">\n            <input type="checkbox" id="roll-disadvantage" name="disadvantage" />\n            Disadvantage (Roll twice, use lower)\n          </label>\n        </div>\n\n        <div class="form-group">\n          <label for="roll-bonus">Bonus:</label>\n          <input type="number" id="roll-bonus" name="bonus" value="0" min="0" />\n        </div>\n\n        <div class="form-group">\n          <label for="roll-penalty">Penalty:</label>\n          <input type="number" id="roll-penalty" name="penalty" value="0" min="0" />\n        </div>\n    ';return"attack"===this.rollType&&(l+='\n        <div class="form-group">\n          <label for="roll-critical-confirm">\n            <input type="checkbox" id="roll-critical-confirm" name="criticalConfirm" />\n            Confirming Critical\n          </label>\n        </div>\n\n        <div class="form-group">\n          <label for="attack-type">Attack Type:</label>\n          <select id="attack-type" name="attackType">\n            <option value="normal">Normal Attack</option>\n            <option value="touch">Touch Attack</option>\n            <option value="flatfooted">vs Flat-Footed</option>\n          </select>\n        </div>\n      '),"save"===this.rollType&&(l+='\n        <div class="form-group">\n          <label for="save-dc">DC to Beat:</label>\n          <input type="number" id="save-dc" name="saveDC" value="10" min="1" />\n        </div>\n      '),"skill"===this.rollType&&(l+='\n        <div class="form-group">\n          <label for="skill-dc">DC (if applicable):</label>\n          <input type="number" id="skill-dc" name="skillDC" value="10" min="1" />\n        </div>\n      '),l+="</form>",l}readFromHTML(l){const t=l.find("form")[0];t&&(this.rollConfig.advantage=t.querySelector('[name="advantage"]')?.checked||!1,this.rollConfig.disadvantage=t.querySelector('[name="disadvantage"]')?.checked||!1,this.rollConfig.bonus=parseInt(t.querySelector('[name="bonus"]')?.value||0),this.rollConfig.penalty=parseInt(t.querySelector('[name="penalty"]')?.value||0),"attack"===this.rollType&&(this.rollConfig.criticalConfirm=t.querySelector('[name="criticalConfirm"]')?.checked||!1,this.rollConfig.attackType=t.querySelector('[name="attackType"]')?.value||"normal"),"save"===this.rollType&&(this.rollConfig.saveDC=parseInt(t.querySelector('[name="saveDC"]')?.value||10)),"skill"===this.rollType&&(this.rollConfig.skillDC=parseInt(t.querySelector('[name="skillDC"]')?.value||10)))}}export class RollResultEvaluator{constructor(l,t={}){this.roll=l,this.config=t}evaluateSuccess(l){if(!l)return null;const t=this.roll.total,e=t>=l,a=20===this.roll.terms[0]?.results?.[0]?.result,n=1===this.roll.terms[0]?.results?.[0]?.result;return{success:e&&!n,failure:!e||n,criticalSuccess:a,criticalFailure:n,margin:t-l,total:t,dc:l}}getResultString(l){const t=this.evaluateSuccess(l);if(!t)return"Roll complete";let e=`**Total: ${t.total}**`;return t.criticalSuccess?e+=" - **CRITICAL SUCCESS!**":t.criticalFailure?e+=" - **CRITICAL FAILURE!**":t.success?e+=` - Success (by ${t.margin})`:e+=` - Failure (by ${Math.abs(t.margin)})`,e}formatForChat(){const l=this.roll.terms,t=l[0];let e=0;for(let t=2;t<l.length;t++)"number"==typeof l[t]?e+=l[t]:void 0!==l[t].number&&(e+=l[t].number);return{d20Result:t.results?.[0]?.result||0,modifier:e,total:this.roll.total,formula:this.roll.formula}}}export class AdvancedRoller{static async rollWithAdvantage(l,t,e={}){if(e.advantage||e.disadvantage){const a=new Roll(t,l.getRollData()),n=new Roll(t,l.getRollData());await a.evaluate(),await n.evaluate();return e.advantage&&a.total>=n.total?a:n}const a=new Roll(t,l.getRollData());return await a.evaluate(),a}static buildFormula(l,t=0,e=0){let a=l;return t>0&&(a+=` + ${t}`),e>0&&(a+=` - ${e}`),a}static async quickAttackRoll(l,t={}){const e=`1d20 + ${(t.bonus||0)-(t.penalty||0)}`;return this.rollWithAdvantage(l,e,t)}static async quickSkillRoll(l,t,e={}){const a=`1d20 + ${t+(e.bonus||0)-(e.penalty||0)}`;return this.rollWithAdvantage(l,a,e)}static async quickSaveRoll(l,t,e={}){const a=`1d20 + ${t+(e.bonus||0)-(e.penalty||0)}`;return this.rollWithAdvantage(l,a,e)}}