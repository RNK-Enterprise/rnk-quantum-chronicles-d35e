// @ts-nocheck
export class ItemActivity{constructor(t,e={}){this.item=t,this.name=e.name||"Activity",this.type=e.type||"generic",this.activation={type:e.activation?.type||"action",cost:e.activation?.cost||1},this.results=[]}async execute(t,e={}){switch(console.log(`Executing activity: ${this.name}`,{item:this.item.name,actor:t.name}),this.type){case"attack":return this.rollAttack(t,e);case"damage":return this.rollDamage(t,e);case"cast":return this.castSpell(t,e);case"ability":return this.useAbility(t,e);default:return this.genericRoll(t,e)}}async rollAttack(t,e={}){const s=this.getAttackBonus(t,e),a=new Roll(`1d20 + ${s}`,t.getRollData());await a.evaluate();const i=await this.createChatMessage(t,a,"attack",e);return this.results.push({type:"attack",roll:a,message:i}),{roll:a,message:i}}async rollDamage(t,e={}){const s=this.getDamageFormula(t,e);if(!s)return console.warn("No damage formula found"),null;const a=new Roll(s,t.getRollData());await a.evaluate();const i=await this.createChatMessage(t,a,"damage",e);return this.results.push({type:"damage",roll:a,message:i}),{roll:a,message:i}}async castSpell(t,e={}){const s=this.getSpellDC(t,e),a=await this.createSpellMessage(t,s,e);return this.results.push({type:"spell",spellDC:s,message:a}),{spellDC:s,message:a}}async useAbility(t,e={}){const s=await this.createAbilityMessage(t,e);return this.results.push({type:"ability",message:s}),{message:s}}async genericRoll(t,e={}){const s=e.formula||"1d20",a=new Roll(s,t.getRollData());await a.evaluate();const i=await this.createChatMessage(t,a,"generic",e);return this.results.push({type:"generic",roll:a,message:i}),{roll:a,message:i}}getAttackBonus(t,e={}){let s=0;t.system?.attributes?.bab&&(s+=t.system.attributes.bab.total||0);const a=this.item.system?.properties?.ability||"str";if(t.system?.abilities?.[a]){s+=Math.floor((t.system.abilities[a].value-10)/2)}return this.item.system?.enhancement&&(s+=this.item.system.enhancement),e.bonus&&(s+=e.bonus),s}getDamageFormula(t,e={}){let s="1d8";this.item.system?.damage?.parts?.[0]?.[0]?s=this.item.system.damage.parts[0][0]:this.item.system?.damage?.dice&&(s=this.item.system.damage.dice);const a=this.item.system?.properties?.ability||"str";let i=0;t.system?.abilities?.[a]&&(i=Math.floor((t.system.abilities[a].value-10)/2));const l=this.item.system?.enhancement||this.item.system?.properties?.enhancement||0;let n=s;return 0!==i&&(n+=` + ${i}`),l>0&&(n+=` + ${l}`),e.bonus&&(n+=` + ${e.bonus}`),n}getSpellDC(t,e={}){const s=this.item.system?.spellStat||"int",a=this.item.system?.level||0;let i=0;return t.system?.abilities?.[s]&&(i=Math.floor((t.system.abilities[s].value-10)/2)),10+a+i}async createChatMessage(t,e,s="generic",a={}){const i=this.formatRollMessage(t,e,s,a),l={user:game.user.id,speaker:ChatMessage.getSpeaker({actor:t}),content:i,rolls:[e]};return ChatMessage.create(l)}async createSpellMessage(t,e,s={}){const a=`\n      <div class="spell-cast-message">\n        <h3>${this.item.name}</h3>\n        <p><strong>DC:</strong> ${e}</p>\n        <p>${this.item.system?.description?.value||""}</p>\n      </div>\n    `,i={user:game.user.id,speaker:ChatMessage.getSpeaker({actor:t}),content:a};return ChatMessage.create(i)}async createAbilityMessage(t,e={}){const s=`\n      <div class="ability-message">\n        <h3>${this.item.name}</h3>\n        <p>${this.item.system?.description?.value||""}</p>\n      </div>\n    `,a={user:game.user.id,speaker:ChatMessage.getSpeaker({actor:t}),content:s};return ChatMessage.create(a)}formatRollMessage(t,e,s="generic",a={}){const i=e.total,l=e.formula;let n=s.charAt(0).toUpperCase()+s.slice(1);return`\n      <div class="roll-message ${s}">\n        <h3>${this.item.name} - ${n}</h3>\n        <div class="roll-result">\n          <strong>Result:</strong> ${i}\n          <span class="formula">(${l})</span>\n        </div>\n        <div class="dice-details">\n          ${e.terms.map(t=>t.results?`<span>${t.results.map(t=>t.result).join(", ")}</span>`:`<span>${t}</span>`).join(" ")}\n        </div>\n      </div>\n    `}}export class WeaponActivity extends ItemActivity{constructor(t){super(t,{name:`${t.name} Attack`,type:"attack"}),this.isWeaponAttack=!0}async execute(t,e={}){const s=await this.rollAttack(t,e);if(s.roll.total>1&&!1!==e.autoRollDamage){return{attack:s,damage:await this.rollDamage(t,e)}}return s}}export class SpellActivity extends ItemActivity{constructor(t){super(t,{name:`Cast ${t.name}`,type:"cast"}),this.isSpell=!0}}